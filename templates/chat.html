<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Storyboard-AI - Your personal storyteller, animator, reader, designer, producer, and narrator.">
  <meta name="author" content="Andrea Filiberto Lucas & Sean David Muscat">
  <meta name="robots" content="index, follow">

  <!-- Open Graph Meta Tags for Social Media -->
  <meta property="og:title" content="Storyboard-AI - Your Personal Storyteller">
  <meta property="og:description" content="Storyboard-AI creates personalized stories with animation, narration, and design tailored to you.">
  <meta property="og:image" content="{{ url_for('serve_assets', filename='img/hero-bg.jpg') }}">
  <meta property="og:type" content="website">
  <title>Chat - Storyboard-AI</title>

  <!-- Favicons -->
  <link id="favicon" rel="icon" href="{{ url_for('serve_assets', filename='img/faviconSB.png') }}" 
    data-light-icon="{{ url_for('serve_assets', filename='img/faviconSB.png') }}" 
    data-dark-icon="{{ url_for('serve_assets', filename='img/faviconSBDark.png') }}">

  <link id="apple-touch-icon" rel="apple-touch-icon" href="{{ url_for('serve_assets', filename='img/faviconSB.png') }}" 
    data-light-icon="{{ url_for('serve_assets', filename='img/faviconSB.png') }}" 
    data-dark-icon="{{ url_for('serve_assets', filename='img/faviconSBDark.png') }}">

  <!-- Fonts -->
  <link href="https://fonts.googleapis.com" rel="preconnect">
  <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@100;300;400;500;700;900&family=Poppins:wght@100;200;300;400;500;600;700;800;900&family=Raleway:wght@100;200;300;400;500;600;700;800;900&display=swap" rel="stylesheet">

  <!-- Vendor CSS Files -->
  <link href="{{ url_for('serve_assets', filename='vendor/bootstrap-icons/bootstrap-icons.css') }}" rel="stylesheet">
  <link href="{{ url_for('serve_assets', filename='vendor/bootstrap/css/bootstrap.min.css') }}" rel="stylesheet">
  <link href="{{ url_for('serve_assets', filename='vendor/glightbox/css/glightbox.min.css') }}" rel="stylesheet">
  <link href="{{ url_for('serve_assets', filename='vendor/aos/aos.css') }}" rel="stylesheet">
  <link href="{{ url_for('serve_assets', filename='vendor/swiper/swiper-bundle.min.css') }}" rel="stylesheet">

  <!-- Main CSS File -->
  <link href="{{ url_for('serve_assets', filename='css/main.css') }}" rel="stylesheet">

  <script src="{{ url_for('serve_assets', filename='js/chat.js') }}" defer></script>

  <!-- Include pdfmake library for PDF generation -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdfmake/0.1.69/pdfmake.min.js"></script>
  <!-- Include vfs_fonts.js, required for handling embedded fonts in pdfmake -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdfmake/0.1.69/vfs_fonts.js"></script>
</head>

<body class="index-page" style="margin-top: 0px; height: 100%;">
  <!-- Header Section -->
  <header id="header" class="header d-flex flex-column justify-content-center" role="banner">
    <i class="header-toggle d-xl-none bi bi-list" aria-label="Toggle navigation menu"></i>
    <nav id="navmenu" class="navmenu" role="navigation">
      <ul>
        <li><a href="/home"><i class="bi bi-house navicon"></i><span>Home</span></a></li>
        <li><a href="/profile"><i class="bi bi-person navicon"></i><span>Profile</span></a></li>
        <li><a href="" class="active" aria-current="page"><i class="bi bi-chat-left-dots"></i><span>Chat</span></a></li>
        <li><a href="/history"><i class="bi bi-clock-history"></i><span>History</span></a></li>
        <li><a href="#" id="signout-btn"><i class="bi bi-box-arrow-right"></i><span>Signout</span></a></li>
      </ul>
    </nav>
  </header>

  <main class="main">
    <section class="chatbot">
      <div class="card-body" style="margin: 0cm; padding: 0cm; height: auto; width: 100%;">
        <!-- Chat history container -->
        <div class="chatbox">
          <div class="messages" id="message-container" aria-live="polite" aria-atomic="true">
            <!-- Messages will dynamically load here -->
          </div>
        </div>
    
        <!-- User input container -->
        <div class="input-container">
          <div class="input-group">
            <!-- Input field for user message -->
            <input 
              type="text" 
              id="chat-input" 
              class="form-control" 
              placeholder="Message Storyboard-AI" 
              aria-label="Enter your message for Storyboard-AI"
              style="padding-right: 3rem;" 
            />
            
            <!-- Microphone button for speech recognition -->
            <button 
              class="btn btn-outline-secondary input-group-text" 
              type="button" 
              id="mic-button" 
              aria-label="Enable voice input"
            >
              <i class="bi bi-mic" aria-hidden="true"></i>
            </button>
          </div>
    
          <!-- Send message button -->
          <button 
            id="send-button" 
            class="btn btn-primary" 
            style="font-size: large;" 
            aria-label="Send message"
          >
            â†‘
          </button>
        </div>
    
        <!-- Disclaimer message -->
        <p class="message-text text-muted small mt-2">
            Storyboard-AI may generate content that doesn't fully align with your vision.
        </p>
      </div>
    </section>

  <script>
    // Ensure browser compatibility for SpeechRecognition
    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;

    if (!SpeechRecognition) {
        document.getElementById('chat-input').placeholder = "Speech recognition is not supported in this browser.";
    }

    // Initialize SpeechRecognition
    const recognition = new SpeechRecognition();
    recognition.lang = 'en-US';
    recognition.continuous = false;
    recognition.interimResults = true;

    // DOM elements
    const micButton = document.getElementById("mic-button");
    const sendButton = document.getElementById("send-button");
    const chatInput = document.getElementById("chat-input");
    const messageContainer = document.getElementById("message-container");

    // Colors
    const ACTIVE_MIC_COLOR = '#0563bb'; // Blue
    const DEFAULT_MIC_COLOR = '#272829'; // Grey
    const ERROR_MIC_COLOR = 'red';

    // Function to get the current favicon URL (either light or dark)
    function getCurrentFavicon() {
        const faviconElement = document.getElementById('favicon');
        const lightIcon = faviconElement.getAttribute('data-light-icon');
        const darkIcon = faviconElement.getAttribute('data-dark-icon');

        // Check which icon is currently used and return it
        const currentFavicon = faviconElement.getAttribute('href') === lightIcon ? lightIcon : darkIcon;
        return currentFavicon;
    }

    // Update the bot icon to match the current favicon
    function updateBotIcon() {
        const botIcon = document.querySelector('.bot-icon');
        const currentFavicon = getCurrentFavicon();
        botIcon.src = currentFavicon; // Update the bot icon's source to the current favicon
    }

    // Run the function to update the bot icon when the page loads
    window.addEventListener('DOMContentLoaded', () => {
        updateBotIcon();  // Set the bot icon based on initial favicon
    });

    // Add listener to detect favicon changes if needed
    document.addEventListener('DOMContentLoaded', function() {
        const favicon = document.getElementById('favicon');
        if (favicon) {
            updateBotIcon(); // Set initial icon based on the favicon when the page is loaded
        }
    });

    // Run the function to update the bot icon when the page loads
    window.addEventListener('DOMContentLoaded', updateBotIcon);

    // Optionally, set up a listener for theme changes (light/dark mode)
    window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', updateBotIcon);

    // Speech recognition events
    recognition.onstart = () => {
        micButton.innerHTML = `<i class="bi bi-mic-fill"></i>`;
        micButton.style.color = ACTIVE_MIC_COLOR;
        chatInput.placeholder = "Listening...";
    };

    recognition.onend = () => {
        micButton.innerHTML = `<i class="bi bi-mic"></i>`;
        micButton.style.color = DEFAULT_MIC_COLOR;
        chatInput.placeholder = "Message Storyboard-AI";
    };

    recognition.onresult = (event) => {
        let transcript = '';
        for (let i = event.resultIndex; i < event.results.length; i++) {
            transcript += event.results[i][0].transcript;
        }
        chatInput.value = transcript;
    };

    recognition.onerror = (event) => {
        if (event.error === 'not-allowed') {
            chatInput.placeholder = "Permission to use the microphone was denied";
            micButton.innerHTML = `<i class="bi bi-mic-slash-fill"></i>`;
            micButton.style.color = ERROR_MIC_COLOR;
        } else {
            chatInput.placeholder = "Error occurred during speech recognition.";
            // Update bot icon on error
            updateBotIcon();
        }
    };

    // Check microphone permission
    function requestMicrophonePermission() {
        navigator.permissions.query({ name: 'microphone' }).then((result) => {
            if (result.state === 'denied') {
                chatInput.placeholder = "Microphone access is required for voice input";
                micButton.innerHTML = `<i class="bi bi-mic-mute"></i>`;
                micButton.style.color = ERROR_MIC_COLOR;
                micButton.disabled = true;
                micButton.style.opacity = 0.6;
            } else {
                micButton.disabled = false;
                micButton.style.opacity = 1;
            }
        }).catch((error) => {
            console.error("Permission error:", error);
            chatInput.placeholder = "Unable to check microphone permission";
            // Update bot icon on permission error
            updateBotIcon();
        });
    }

    // Mic button functionality
    micButton.addEventListener('click', () => {
        if (micButton.innerHTML.includes('mic-slash-fill')) {
            navigator.permissions.query({ name: 'microphone' }).then((result) => {
                if (result.state !== 'denied') recognition.start();
            });
        } else if (micButton.innerHTML.includes('mic-fill')) {
            recognition.stop();
        } else {
            recognition.start();
        }
    });

    // Initialize variables for user inputs
    let characterName = "";
    let storyTheme = "";
    let storyEnding = "";
    let additionalNotes = "";
    let currentStep = 0; // To track the conversation flow
    // Fetch the current user's name from localStorage and extract the first name
    const currentUser = (localStorage.getItem("currentuser") || "").split(" ")[0];
    
    // Function to handle chatbot interaction
    function askForInput() {
        let botMessageText = "";
        // Set bot message based on the current step in the conversation
        switch (currentStep) {
            case 0:
                const variations0 = [
                    `Hey ${currentUser}, welcome to Storyboard-AI! Letâ€™s kick things off and create an incredible story together.`,
                    `Hi ${currentUser}! Iâ€™m Storyboard-AI, and I'm excited to help you bring your story ideas to life!`,
                    `Hello ${currentUser}! Ready to start creating an awesome story with Storyboard-AI?`,
                    `Welcome aboard ${currentUser}! I am here to help you create an amazing story.`,
                    `Hey there ${currentUser}, Iâ€™m Storyboard-AI, and I canâ€™t wait to help you create something amazing!`
                ];
                botMessageText = variations0[Math.floor(Math.random() * variations0.length)];
                setTimeout(() => {
                    currentStep++;
                    askForInput();
                }, Math.random() * 1000 + 1000); // Random time between 1000ms (1 second) and 2000ms (2 seconds)
                break;
            case 1:
                const variations1 = [
                    `Iâ€™ll be asking you a few questions to better understand your vision for the story. Letâ€™s dive in!`,
                    `Iâ€™ve got a few questions that will help me get a clearer picture of what you have in mind. Letâ€™s get started!`,
                    `Iâ€™ll be asking you some questions to make sure I fully understand your ideas for the story.`,
                    `Iâ€™ll be first asking a few questions to help shape your story just the way you imagine it.`,
                    `Okay so... letâ€™s get going with some questions to make sure your story turns out just as you envision it.`
                ];
                botMessageText = variations1[Math.floor(Math.random() * variations1.length)];
                setTimeout(() => {
                    currentStep++;
                    askForInput();
                }, Math.random() * 1000 + 1000); // Random time between 1000ms (1 second) and 2000ms (2 seconds)
                break;
            case 2:
                const variations2 = [
                    `Firstly ${currentUser}.... whatâ€™s the name of the main character in your story?`,
                    `Ok ${currentUser}, so what will your main character be called?`,
                    `So ${currentUser}.... whatâ€™s the name of the protagonist in your story?`,
                    `Alright ${currentUser}.... can you please tell me the name of your main character?`,
                    `First thingâ€™s first ${currentUser}... whatâ€™s the name of your main character?`
                ];
                botMessageText = variations2[Math.floor(Math.random() * variations2.length)];
                break;
            case 3:
                const variations3 = [
                    `Cool! Now, could you tell me what kind of theme youâ€™d like for your story. Adventure? Romance? Mystery? Or maybe something more unique?`,
                    `Next, whatâ€™s the theme of your story? Adventure, romance, mystery... or maybe something completely different?`,
                    `What theme are you thinking for your story? Could be adventure, romance, mystery... or maybe something unique!`,
                    `Great! Now, what kind of theme would you like? Something like adventure, romance, or mystery?`,
                    `Awesome! So, whatâ€™s the vibe of your story? Adventure, romance, mystery... or perhaps something entirely original?`
                ];
                botMessageText = variations3[Math.floor(Math.random() * variations3.length)];
                break;
            case 4:
                const variations4 = [
                    `And how would you like the story to end? A happy ending, a shocking twist, or something bittersweet?`,
                    `So now let me know how youâ€™d like the story to wrap up. A happy ending, a twist, or maybe something bittersweet?`,
                    `Another question for you.... what kind of ending do you envision for your story? A happy ending, a surprising twist, or a bittersweet finale?`,
                    `Dam ok... and how do you want the story to end? A happy ending, a shocking twist, or perhaps something bittersweet?`,
                    `Got it! And whatâ€™s your ideal ending for the story? A happy resolution, a twist, or maybe something bittersweet?`
                ];
                botMessageText = variations4[Math.floor(Math.random() * variations4.length)];
                break;
            case 5:
                const variations5 = [
                    `Is there anything else youâ€™d like to add? A special scene, a character trait, or a plot twist?`,
                    `Anything else youâ€™d like to include in your story?`,
                    `Is there any extra detail youâ€™d like to add?`,
                    `Last question I promise ðŸ˜…. Got any special additions to the story? A unique scene, a special trait, or maybe a plot twist?`,
                    `Before we wrap up, is there anything else youâ€™d like to include? A cool scene, character trait, or a twist?`
                ];
                botMessageText = variations5[Math.floor(Math.random() * variations5.length)];
                break;
            case 6:
                const variations6 = [
                    `OMG SO COOL! Iâ€™ve got everything I need. Time to work some magic and create your story! âœ¨`,
                    `Perfect! I have all the info I need. Now, let me work my magic! Just sit back and let me craft something special for you! âœ¨`,
                    `Awesome! Iâ€™ll start putting it all together to create your story! âœ¨`,
                    `Great! Sit tight, while I create something amazing for you! âœ¨`,
                    `Awesome, everythingâ€™s in place! Iâ€™m about to create your story. Hang on tight while I make something truly magical for youâœ¨`
                ];
                botMessageText = variations6[Math.floor(Math.random() * variations6.length)];
                    // Display the bot message to the user
                    const generatingMessage = document.createElement("div");
                    generatingMessage.classList.add("message", "bot-message");
                    generatingMessage.innerHTML = `
                        <div class="message-content_bot">
                            <div class="message-icon_bot">
                                <img src="${getCurrentFavicon()}" alt="SB-AI Logo" class="bot-icon">
                            </div>
                            <div class="message-text">
                                <p style="margin-bottom: 14px;">${botMessageText}</p>
                                <i class="bi bi-volume-up speaker-icon" onclick="speakText('${botMessageText}', this)" style="font-size: 1.2em; cursor: pointer; color: var(--accent-color);"></i> <!-- Speaker icon -->
                            </div>
                        </div>`;
                    messageContainer.appendChild(generatingMessage);
                    messageContainer.scrollTop = messageContainer.scrollHeight;
                    // All inputs are gathered, create the final prompt
                    const finalPrompt = `
                        You are a brilliant storyteller with a talent for crafting immersive, engaging, and well-structured narratives. Your task is to create a continuous story featuring a character named "${characterName}" within the theme of "${storyTheme}." The narrative should flow seamlessly, with vivid settings, compelling events, and natural dialogue, building toward a "${storyEnding}" ending that feels satisfying and true to the story's tone.
                        Important: Incorporate the following user note(s) where relevant: "${additionalNotes || 'No additional notes were provided.'}"

                        Write the story as a uninterrupted narrative in simple paragraph(s) format. Avoid titles, character lists, headings, subheadings, or any structural divisions. Keep the flow natural and seamless, without breaks or pauses between sections. The story should unfold from start to finish in a single, cohesive pieceâ€”just one continuous narrative.
                        Ensure the content is appropriate for all readers of all ages, steering clear of violence, harm, or any offensive material. Focus on creating a thoughtful, imaginative, and uplifting story that appeals to a wide, diverse audience. If the narrative starts to take a negative turn, guide it back to a positive, respectful tone, upholding a sense of inclusivity.
                        Your storytelling should be creative, captivating, and engagingâ€”leaving readers with a lasting, positive impression. Aim for a memorable and respectful narrative that draws readers in from the first sentence to the last.`;
                                            
                    console.log("Final Prompt Sent to TinyLlama:\n", finalPrompt);
                    // Send the prompt to TinyLlama
                    fetch("http://127.0.0.1:5000/chat", {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({ prompt: finalPrompt }),
                    })
                    .then(response => response.json())
                    .then(data => {
                        // Split the response by line breaks (or paragraphs)
                        const botMessages = data.response.split(/\n+/); // Split by one or more newline characters

                        // Function to simulate typing animation for '...'
                        function showTypingAnimation(paragraph) {
                            const typingMessage = document.createElement("div");
                            typingMessage.classList.add("message", "bot-message");
                            typingMessage.innerHTML = `
                                <div class="message-content_bot">
                                    <div class="message-icon_bot">
                                        <img src="${getCurrentFavicon()}" alt="SB-AI Logo" class="bot-icon">
                                    </div>
                                    <div class="message-text">
                                        <p>${paragraph}</p>
                                    </div>
                                </div>`;
                            messageContainer.appendChild(typingMessage);
                            messageContainer.scrollTop = messageContainer.scrollHeight;

                            // Return the typingMessage to be updated later
                            return typingMessage;
                        }

                        // Function to simulate the typing of '...'
                        function animateDots(typingMessage) {
                            return new Promise(resolve => {
                                let dots = '';
                                let dotCount = 0;

                                // Use a setInterval to simulate typing of dots
                                const typingInterval = setInterval(() => {
                                    dots += '.'; // Add a dot

                                    // Update the message with the new dots
                                    typingMessage.querySelector(".message-text p").innerText = dots;

                                    // If the dot count reaches 3, reset to 0 dots
                                    dotCount++;
                                    if (dotCount === 3) {
                                        dots = '';  // Reset to 0 dots
                                        dotCount = 0;  // Reset the counter
                                    }
                                }, 500); // Adjust speed here (500ms)

                                // Stop typing after a certain time
                                setTimeout(() => {
                                    clearInterval(typingInterval); // Stop typing
                                    resolve(); // Resolve the promise to continue
                                }, 3000); // Adjust the duration to control how long the typing effect lasts
                            });
                        }

                        // Function to simulate typing animation for paragraphs (human-like typing with cursor)
                        function typeParagraphWithCursor(typingMessage, paragraph) {
                            return new Promise(resolve => {
                                let index = 0;
                                const typingInterval = setInterval(() => {
                                    // Add the character to the text and append the cursor
                                    typingMessage.querySelector(".message-text p").innerText = paragraph.slice(0, index + 1) + '|';
                                    index++;

                                    if (index === paragraph.length) {
                                        clearInterval(typingInterval);
                                        // Once the paragraph is done, initiate the blinking effect on the cursor
                                        blinkCursor(typingMessage, paragraph).then(() => {
                                            // Add the speaker icon once typing is done
                                            addSpeakerIcon(typingMessage, paragraph);
                                            addRedoButton(typingMessage, paragraph); // Add the redo button
                                            makeTextClickable(typingMessage, paragraph); // Enable text click functionality
                                            resolve(); // Resolve the promise to continue
                                        });
                                    }
                                }, 25); // Typing speed, you can adjust this value
                            });
                        }

                        function addSpeakerIcon(typingMessage, paragraph) {
                            const speakerIconContainer = typingMessage.querySelector(".message-text");
                            const speakerIcon = document.createElement("i"); // Use <i> for Bootstrap icons

                            // Add Bootstrap speaker icon classes
                            speakerIcon.classList.add("speaker-icon", "bi", "bi-volume-up");

                            // Style the icon to use var(--accent-color)
                            speakerIcon.style.color = "var(--accent-color)";
                            speakerIcon.style.cursor = "pointer"; // Add a pointer cursor for better UX

                            // On click, call the text-to-speech function
                            speakerIcon.onclick = () => speakText(paragraph, speakerIcon);

                            // Append the speaker icon after the text has been typed
                            speakerIconContainer.appendChild(speakerIcon);
                        }

                        function addRedoButton(typingMessage, paragraph) {
                            const redoButton = document.createElement("button");
                            redoButton.innerHTML = `<i class="bi bi-arrow-repeat"></i> Redo`; // Bootstrap icon for redo
                            redoButton.classList.add("redo-button", "btn", "btn-outline-primary", "btn-sm"); // Bootstrap classes for styling

                            const messageContent = typingMessage.querySelector(".message-content_bot");
                            const messageText = messageContent.querySelector(".message-text");

                            // Add the redo button next to the message text
                            messageText.appendChild(redoButton);

                            redoButton.onclick = () => {
                                // Temporarily hide the paragraph while it's being rewritten
                                messageText.querySelector("p").innerText = "Rewriting...";

                                // Send the prompt to TinyLlama to re-write the paragraph
                                rewriteParagraph(paragraph).then(newParagraph => {
                                    // Update the message with the rewritten paragraph
                                    messageText.querySelector("p").innerText = newParagraph;

                                    // Update the botMessages array with the rewritten paragraph
                                    const paragraphIndex = botMessages.indexOf(paragraph);
                                    if (paragraphIndex !== -1) {
                                        botMessages[paragraphIndex] = newParagraph; // Update the original array
                                    }
                                }).catch(error => {
                                    console.error("Error rewriting paragraph:", error);
                                });
                            };
                        }

                        function rewriteParagraph(paragraph) {
                            return new Promise(resolve => {
                                // Define a stronger prompt to rewrite the paragraph
                                const finalPrompt = `You are a rewriting assistant. Your task is to rewrite the following paragraph according to these guidelines:

                                - Keep the original meaning, tone, and context.
                                - Ensure the length is similar, concise but thorough.
                                - Use varied wording and sentence structures to enhance readability while maintaining key details.
                                - Do not include any introductory phrases, commentary, or explanations. Only provide the rewritten paragraph.

                                Example:
                                Original paragraph:
                                "Sean stood at the edge of the cliff, staring at the horizon. The wind whipped through his hair as he thought about the long journey ahead. He was ready for whatever came next."

                                Rewritten paragraph:
                                "Standing on the cliff's edge, Sean gazed out at the horizon. The wind tugged at his hair as he contemplated the journey ahead, feeling prepared for whatever challenges awaited him."

                                Here is the paragraph to rewrite:
                                "${paragraph}"`;

                                // Send the prompt to TinyLlama
                                fetch("http://127.0.0.1:5000/chat", {
                                    method: "POST",
                                    headers: { "Content-Type": "application/json" },
                                    body: JSON.stringify({ prompt: finalPrompt }),
                                })
                                .then(response => response.json())
                                .then(data => {
                                    const rewrittenParagraph = data.response; // Assume the response contains the rewritten paragraph
                                    resolve(rewrittenParagraph); // Resolve the promise with the new paragraph
                                })
                                .catch(error => {
                                    console.error("Error rewriting paragraph:", error);
                                    resolve(paragraph); // If thereâ€™s an error, return the original paragraph
                                });
                            });
                        }
                        
                        function makeTextClickable(typingMessage, paragraph) {
                            const paragraphElement = typingMessage.querySelector(".message-text p");

                            // Add a click event listener to the paragraph
                            paragraphElement.style.cursor = 'pointer'; // Change cursor to pointer to indicate it's clickable

                            paragraphElement.onclick = () => {
                                copyToClipboard(paragraph); // Call the copyToClipboard function on click
                            };
                        }

                        function copyToClipboard(text) {
                            // Create a temporary textarea element to hold the text to be copied
                            const tempTextArea = document.createElement("textarea");
                            tempTextArea.value = text;
                            document.body.appendChild(tempTextArea);

                            // Select the text in the textarea and copy it to the clipboard
                            tempTextArea.select();
                            document.execCommand('copy');

                            // Remove the textarea after copying
                            document.body.removeChild(tempTextArea);

                            // Optional: Provide feedback to the user (e.g., alert or visual cue)
                            alert("Text copied to clipboard!"); // You can change this to a more user-friendly notification
                        }


                        // Function to blink the cursor twice before disappearing
                        function blinkCursor(typingMessage, paragraph) {
                            return new Promise(resolve => {
                                const cursor = typingMessage.querySelector(".message-text p");
                                let blinkCount = 0;
                                
                                // Make the cursor blink twice
                                const blinkInterval = setInterval(() => {
                                    if (blinkCount < 2) {
                                        // Toggle the cursor visibility (blink effect)
                                        cursor.innerText = cursor.innerText.endsWith('|') ? paragraph : paragraph + '|';
                                        blinkCount++;
                                    } else {
                                        clearInterval(blinkInterval);
                                        // Remove the cursor after blinking
                                        cursor.innerText = paragraph;
                                        resolve();
                                    }
                                }, 500); // Blink every 500ms
                            });
                        }

                        // Function to append the message after a delay and update the typing animation
                        function appendMessageWithDelay(typingMessage, paragraph, delay) {
                            return new Promise(resolve => {
                                setTimeout(() => {
                                    // Update the typing message with the actual paragraph after the delay
                                    typeParagraphWithCursor(typingMessage, paragraph).then(resolve);
                                }, delay);
                            });
                        }
                        
                        function generateTitleForStory(story) {
                            // Prepare the prompt for generating the title
                            const titlePrompt = `You are a title-crafting expert, skilled at creating concise and captivating titles that encapsulate the mood, theme, and core message of a story. Your task is to generate a title for the provided story based on the following guidelines:

                            - The title should be no longer than 7 words.
                            - It must reflect the essence of the story, including its mood, theme, and key message.
                            - Ensure the title is clear, relevant, and intriguing without being overly vague or abstract.
                            - Respond with only the title, avoiding any additional commentary or explanation.
                            Here is the story:
                            "${story}"`;

                            return new Promise((resolve, reject) => {
                                // Send the request to Ollama
                                fetch("http://127.0.0.1:5000/chat", {
                                    method: "POST",
                                    headers: { "Content-Type": "application/json" },
                                    body: JSON.stringify({ prompt: titlePrompt }),
                                })
                                    .then(response => {
                                        if (!response.ok) {
                                            throw new Error("Failed to fetch the title from Ollama");
                                        }
                                        return response.json();
                                    })
                                    .then(data => {
                                        const title = data.response?.trim() || "Untitled Story"; // Default to "Untitled Story" if no title is returned
                                        resolve(title); // Resolve the promise with the title
                                    })
                                    .catch(error => {
                                        console.error("Error generating story title:", error);
                                        resolve("Untitled Story"); // Resolve with fallback title in case of error
                                    });
                            });
                        }

                        // Function to save the conversation to a JSON file
                        function saveConversationToJSON(title, userName, story) {
                            // First, we need to load the current conversations from conversations.json
                            fetch('json/conversations.json', {
                                method: 'GET',
                                headers: { 'Content-Type': 'application/json' }
                            })
                            .then(response => response.json())
                            .then(data => {
                                // Add the new conversation to the conversations array
                                const newConversation = {
                                    title: title,
                                    userName: userName,
                                    story: story,
                                    timestamp: new Date().toISOString() // Add a timestamp
                                };

                                // Append the new conversation to the data array
                                data.conversations.push(newConversation);

                                // Now save the updated JSON back to the server or save locally (depending on setup)
                                return fetch('json/conversations.json', {
                                    method: 'POST', // You could use PUT or another method depending on your backend
                                    headers: {
                                        'Content-Type': 'application/json'
                                    },
                                    body: JSON.stringify(data) // Send the updated JSON
                                });
                            })
                            .then(response => {
                                if (response.ok) {
                                    console.log('Conversation saved successfully!');
                                } else {
                                    console.error('Failed to save conversation');
                                }
                            })
                            .catch(error => {
                                console.error('Error saving conversation:', error);
                            });
                        }

                        (async function() {
                            for (let i = 0; i < botMessages.length; i++) {
                                const typingMessage = showTypingAnimation(botMessages[i]); // Create a new element for each message

                                // Wait for the typing dots animation to finish before continuing
                                await animateDots(typingMessage);

                                // Random delay before appending the actual message
                                const randomDelay = Math.floor(Math.random() * 4000) + 1000; // Random delay between 1 and 5 seconds
                                await appendMessageWithDelay(typingMessage, botMessages[i], randomDelay); // Replace ... with the actual paragraph
                            }

                            // Combine all paragraphs into a single story text
                            const story = botMessages.join(" ");
                            console.log(story);

                            // Prepare the prompt for generating the title
                            const titlePrompt = `You need to generate a title for this story, the title should be less than 6 words maximum and only return the title, nothing else. The story is: ${story}`;

                            // Send the request to Ollama to generate the title
                            const response = await fetch("http://127.0.0.1:5000/chat", {
                                method: "POST",
                                headers: { "Content-Type": "application/json" },
                                body: JSON.stringify({ prompt: titlePrompt }),
                            });

                            const result = await response.json();
                            const title = result.response || "Untitled Story"; // Fallback in case no reply is received

                            // Display the title to the user
                            const titleMessage = document.createElement("div");
                            titleMessage.classList.add("message", "bot-message");
                            titleMessage.innerHTML = `
                                <div class="message-content_bot">
                                    <div class="message-icon_bot">
                                        <img src="${getCurrentFavicon()}" alt="SB-AI Logo" class="bot-icon">
                                    </div>
                                    <div class="message-text">
                                        <p><strong>Story Title:</strong> ${title}</p>
                                    </div>
                                </div>`;
                            messageContainer.appendChild(titleMessage);
                            messageContainer.scrollTop = messageContainer.scrollHeight;

                            // Prepare the prompt for generating the 100-word summary
                            const summaryPrompt = `You are a summarizer, tasked with condensing the following story into 100 words or less. Your role is to provide a concise, clear overview of the plot, highlighting the main events, central conflict, and resolution. Focus on the key details that drive the story forward, and omit any unnecessary information. Your summary should be both efficient and informative, capturing the essence of the story in a straightforward manner.
                            Story: "${story}"`;

                            // Send the request to Ollama to generate the summary
                            const summaryResponse = await fetch("http://127.0.0.1:5000/chat", {
                                method: "POST",
                                headers: { "Content-Type": "application/json" },
                                body: JSON.stringify({ prompt: summaryPrompt }),
                            });

                            const summaryResult = await summaryResponse.json();
                            const summary = summaryResult.response || "No summary generated."; // Fallback if no summary is generated

                            // Display the summary to the user
                            const summaryMessage = document.createElement("div");
                            summaryMessage.classList.add("message", "bot-message");
                            summaryMessage.innerHTML = `
                                <div class="message-content_bot">
                                    <div class="message-icon_bot">
                                        <img src="${getCurrentFavicon()}" alt="SB-AI Logo" class="bot-icon">
                                    </div>
                                    <div class="message-text">
                                        <p><strong>Story Summary:</strong> ${summary}</p>
                                    </div>
                                </div>`;
                            messageContainer.appendChild(summaryMessage);
                            messageContainer.scrollTop = messageContainer.scrollHeight;

                            // Ask if the user wants to save the story as a PDF
                            const savePDFButton = document.createElement("button");
                            savePDFButton.innerText = "Save as PDF";
                            savePDFButton.classList.add("save-pdf-button");

                            messageContainer.appendChild(savePDFButton);

                            savePDFButton.onclick = () => {
                                // Call the function to generate and download the PDF with the title and story
                                generateAndDownloadPDF(title, story);
                            };

                            // Save the conversation to conversations.json
                            const currentUser = localStorage.getItem("currentuser") || "Anonymous"; // Retrieve username or default to "Anonymous"
                            const conversationData = {
                                title: title,
                                userName: currentUser,
                                story: story
                            };

                            // Send the data to the server to save it in the JSON file
                            fetch("/save-conversation", {
                                method: "POST",
                                headers: {
                                    "Content-Type": "application/json"
                                },
                                body: JSON.stringify(conversationData)
                            })
                            .then(response => {
                                return response.text(); // Get response as text first
                            })
                            .then(data => {
                                console.log(data); // Log the raw response to check for errors
                                try {
                                    const jsonData = JSON.parse(data); // Try parsing it manually
                                    console.log("Response data:", jsonData);
                                } catch (e) {
                                    console.error("Error parsing JSON:", e);
                                }
                            })
                            .catch(error => {
                                console.error("Error saving conversation:", error);
                            });

                        })();

                        // Function to generate and download the PDF
                        function generateAndDownloadPDF(title, story) {
                            const docDefinition = {
                                content: [
                                    { text: title, style: 'header' },
                                    { text: story, style: 'story' }
                                ],
                                styles: {
                                    header: {
                                        fontSize: 18,
                                        bold: true,
                                        margin: [0, 0, 0, 10]
                                    },
                                    story: {
                                        fontSize: 12,
                                        margin: [0, 10, 0, 10]
                                    }
                                }
                            };

                            // Generate PDF and trigger download
                            pdfMake.createPdf(docDefinition).download('Story.pdf');
                        }



                    })
                    .catch(error => {
                        console.error("Error fetching chatbot response:", error);
                        // Handle error as before
                    })
                    .finally(() => {
                        sendButton.disabled = false;
                        sendButton.innerHTML = "â†‘";
                    });


                    return;
            }

            // Display bot message
            const botMessage = document.createElement("div");
            botMessage.classList.add("message", "bot-message");
            botMessage.innerHTML = `
                <div class="message-content_bot">
                    <div class="message-icon_bot">
                        <img src="${getCurrentFavicon()}" alt="SB-AI Logo" class="bot-icon">
                    </div>
                    <div class="message-text">
                        <p style="margin-bottom: 14px;">${botMessageText}</p>
                        <i class="bi bi-volume-up speaker-icon" onclick="speakText('${botMessageText}', this)" style="font-size: 1.2em; cursor: pointer; color: var(--accent-color)"></i> <!-- Speaker icon -->
                    </div>
                </div>`;
            messageContainer.appendChild(botMessage);
            messageContainer.scrollTop = messageContainer.scrollHeight;
        }

        // Function to handle user responses and progress conversation
        function sendMessage() {
            const userInput = chatInput.value.trim();

            if (userInput) {
                // Display user message
                const userMessage = document.createElement("div");
                userMessage.classList.add("message", "user-message");
                userMessage.innerHTML = `
                    <div class="message-content_user">
                        <div class="message-text_user_input"><p>${userInput}</p></div>
                        <div class="message-icon" style="min-width: 10%">
                            <img src="{{ url_for('static', filename=user_info['profile_pic']) }}" alt="User Icon" class="user-icon">
                        </div>
                    </div>`;
                messageContainer.appendChild(userMessage);
                chatInput.value = "";
                messageContainer.scrollTop = messageContainer.scrollHeight;

                // Save input based on current step
                if (currentStep === 2) {
                    characterName = userInput; // Saving character name
                } else if (currentStep === 3) {
                    storyTheme = userInput; // Saving story theme
                } else if (currentStep === 4) {
                    storyEnding = userInput; // Saving story ending
                } else if (currentStep === 5) {
                    additionalNotes = userInput; // Saving additional notes
                    lockInput(); // Lock the input and buttons after saving additional notes
                }

                // Function to lock input and buttons
                function lockInput() {
                    const inputField = document.getElementById("chat-input");
                    const sendButton = document.getElementById("send-button");
                    const micButton = document.getElementById("mic-button");
                    const inputContainer = document.querySelector(".input-container");

                    // Disable input field and buttons
                    inputField.disabled = true;
                    sendButton.disabled = true;
                    micButton.disabled = true;

                    // Apply styling to permanently grey out the send button
                    sendButton.style.backgroundColor = "#d3d3d3"; // Light grey
                    sendButton.style.borderColor = "#d3d3d3";
                    sendButton.style.cursor = "not-allowed"; // Show 'not allowed' cursor on hover

                    // Ensure the red text message is above the input container
                    const existingLockedMessage = document.getElementById("locked-message");
                    if (!existingLockedMessage) {
                        const lockedMessage = document.createElement("p");
                        lockedMessage.id = "locked-message"; // Add an ID to avoid duplicate messages
                        lockedMessage.textContent = "You cannot send more messages at this stage.";
                        lockedMessage.style.color = "red";
                        lockedMessage.style.marginBottom = "10px"; // Add spacing between the message and the bar
                        lockedMessage.style.textAlign = "center"; // Align text for better appearance
                        lockedMessage.style.fontWeight = "500"; // Semi-bold text
                        lockedMessage.style.fontSize = "1.5rem"; // Larger font size
                        inputContainer.parentNode.insertBefore(lockedMessage, inputContainer); // Insert above the input bar
                    }
                }

                // Move to next step
                currentStep++;
                setTimeout(askForInput, 1000); // Add slight delay for natural interaction
            }
        }

        // Attach event listeners for user interactions
        sendButton.addEventListener("click", (event) => {
            event.preventDefault();
            sendMessage();
        });

        chatInput.addEventListener("keydown", (event) => {
            if (event.key === "Enter") {
                event.preventDefault();
                sendMessage();
            }
        });

        // Start the chatbot conversation
        askForInput();
    // Check permissions on load
    requestMicrophonePermission();
  </script>

  <!-- Additional Info Section -->
    <div id="info-area" style="display: none; margin-bottom: 0; width: 100%;">
        <div class="info-group">
            <h3>About the Storyboard-AI Chatbot</h3>
            <p>
                The <span class="highlight">Storyboard-AI Chatbot</span> utilizes advanced AI technology to help you create personalized stories based on your responses. 
                The chatbot engages you by asking questions and then dynamically generates a complete story, complete with images and video. 
                Additionally, it uses your browserâ€™s <span class="highlight">SpeechSynthesisUtterance</span> feature to provide text-to-speech functionality, allowing the story to be narrated aloud for a richer, more interactive experience.
            </p>
            <p>
                <span class="highlight"><b>Disclaimer:</b></span> The stories created by the chatbot are purely fictional and for entertainment purposes, meant to assist with story generation; however, the system may occasionally produce errors or inaccuracies, resulting in unexpected twists or content deviations.
            </p>
            <p>
                Powered by <a href="https://ollama.com" target="_blank" class="bold-link"><b>&copy; Ollama</b></a> using the <a href="https://ollama.com/library/tinyllama:1.1b-chat" target="_blank" class="bold-link"><b>&copy; TinyLlama:1.1b-chat</b></a> model.
            </p>        
        </div>             
    </div>    
  </main>
  
  <!-- Footer Section -->
  <footer style="position: relative; display: flex; justify-content: center; align-items: center; width: 105%;" id="footer" role="contentinfo">
    <p style="margin-bottom: 0px;">
        <a id="info-button" href="javascript:void(0)" onclick="toggleInfo()" style="font-weight: 500;">Click here to find out more about this page</a>
    </p>
  </footer>
  <footer style="width: 105%;" id="footer" class="footer position-relative light-background" role="contentinfo">   <!-- Width Extra JUST FOR THIS PAGE -->
    <div class="credits">
      Designed by <a href="mailto:andrea.f.lucas.22@um.edu.mt" target="_blank">Andrea Filiberto Lucas</a> & <a href="mailto:sean.muscat.22@um.edu.mt" target="_blank">Sean David Muscat</a>
    </div>
    <div class="credits">
      Template from <a href="https://bootstrapmade.com/">Bootstrap</a>
    </div>
  </footer>

    <style>
    /* Style the footer to stay at the bottom */
    html, body {
        height: 100%; /* Ensure full page height */
        display: flex;
        flex-direction: column; /* Stack content vertically */
        margin: 0;
        padding: 0;
    }

    /* Main Content */
    .main-content {
      width: 100%;
      min-height: 100vh;
      position: relative;
      padding: 80px 0;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    @media (min-width: 1200px) and (max-width: 1600px) {
      .header~main {
        margin-left: 90px;
      }

      .header~main .hero {
        margin-left: -160px;
        width: 100vw;
      }
    }
    </style>

  <!-- Scroll Top -->
  <a href="#" id="scroll-top" class="scroll-top d-flex align-items-center justify-content-center" aria-label="Scroll to top">
    <i class="bi bi-arrow-up-short"></i>
  </a>
  
  <!-- Vendor JS Files -->
  <script src="{{ url_for('serve_assets', filename='vendor/bootstrap/js/bootstrap.bundle.min.js') }}" defer></script>
  <script src="{{ url_for('serve_assets', filename='vendor/aos/aos.js') }}" defer></script>
  <script src="{{ url_for('serve_assets', filename='vendor/typed.js/typed.umd.js') }}" defer></script>
  <script src="{{ url_for('serve_assets', filename='vendor/purecounter/purecounter_vanilla.js') }}" defer></script>
  <script src="{{ url_for('serve_assets', filename='vendor/waypoints/noframework.waypoints.js') }}" defer></script>
  <script src="{{ url_for('serve_assets', filename='vendor/glightbox/js/glightbox.min.js') }}" defer></script>
  <script src="{{ url_for('serve_assets', filename='vendor/swiper/swiper-bundle.min.js') }}" defer></script>

  <!-- Main JS File -->
  <script src="{{ url_for('serve_assets', filename='js/main.js') }}" defer></script>
  <script src="{{ url_for('serve_assets', filename='js/chat.js') }}" defer></script>
</body>
</html>
